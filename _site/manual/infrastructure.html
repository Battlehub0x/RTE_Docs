<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title> | Example Unity documentation </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content=" | Example Unity documentation ">
    
      <link rel="shortcut icon" href="../favicon.ico">
      <link rel="stylesheet" href="../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../styles/docfx.css">
      <link rel="stylesheet" href="../styles/main.css">
      <meta property="docfx:navrel" content="../toc.html">
      <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p>#Common Infrastructure Docs
##Overview</p>
<p>Common infrastructure classes and interfaces form core api of runtime editor. Among other there are <a href="#runtime-selection">selection</a>, <a href="#runtime-objects">object lifecycle</a>,
<a href="#runtime-tools">tools</a>, <a href="#runtime-undo">undo-redo</a> and <a href="#drag-and-drop">drag&amp;drop</a> API's.</p>
<p>##Expose To Editor</p>
<p>Add /Battlehub/RTEditor/Runtime/RTCommon/<strong>ExposeToEditor</strong> component to any Game Object you want to make available for selection and editing.</p>
<p><img src="../resources/img/infrastructure/expose-to-editor/expose-to-editor.png" alt="Screenshot"></p>
<p>UnityEvents:</p>
<ul>
<li><code>Selected Event</code> raised when object added to <a href="#runtime-selection">Runtime Selection</a>.</li>
<li><code>Unselected Event</code> raised when object removed from <a href="#runtime-selection">Runtime Selection</a>.</li>
</ul>
<p>Fields &amp; Properties:</p>
<ul>
<li><code>AddColliders</code> – add colliders to enable selection? (default: true).</li>
<li><code>Bounds Object</code> – reference to the GameObject which will be used to calculate bounds.</li>
<li><code>Custom Bounds</code> – used if BoundsType == Custom.</li>
<li><code>Bounds Type</code>:<br>
* <em>Mesh</em> – MeshFilter.mesh.bounds will be used to calculate bounds.
* <em>SkinnedMesh</em> – SkinnedMeshRenderer.mesh.bounds to calculate bounds.
* <em>Sprite</em> - SpriteRenderer.sprite.bounds will be used to calculate bounds.
* <em>RectTransform</em> CalculateRelativeRectTransformBounds method will be used to calculate bounds.
* <em>Custom</em> – user defined bounds.
* <em>Any</em> – any of the above.</li>
</ul>
<p>##Event methods</p>
<p>Event methods are called for all scripts of game objects with the <a href="#expose-to-editor">Expose To Editor</a> component attached.</p>
<div class="NOTE">
<h5>Note</h5>
<p>RuntimeAwake, RuntimeStart, OnRuntimeDestroy,  OnRuntimeActivate, OnRuntimeDeactivate are called in play mode only.
See <code>IsPlaying</code> property of <a href="#irte-interface">IRTE interface</a></p>
</div>
<pre><code class="lang-C#">using UnityEngine;

public class ScriptEventsExample : MonoBehaviour
{
	private void OnRuntimeEditorOpened()
    {
        Debug.Log(&quot;Editor Opened&quot;);
    }

    private void OnRuntimeEditorClosed()
    {
        Debug.Log(&quot;Editor Closed&quot;);
    }

    private void RuntimeAwake()
    {
        Debug.Log(&quot;Awake in play mode&quot;);
    }

    private void RuntimeStart()
    {
        Debug.Log(&quot;Start in play mode&quot;);
    }

    private void OnRuntimeDestroy()
    {
        Debug.Log(&quot;Destroy in play mode&quot;);
    }

    private void OnRuntimeActivate()
    {
        Debug.Log(&quot;Game View activated&quot;);
    }

    private void OnRuntimeDeactivate()
    {
        Debug.Log(&quot;Game View deactivated&quot;);
    }
}
</code></pre>
<p>##IOC</p>
<p>/Battlehub/RTEditor/Runtime/RTCommon/<strong>IOC</strong> is a simple IoC container implementation.</p>
<p>Methods:</p>
<ul>
<li><code>static T Resolve&lt;T&gt;()</code> - resolve dependency of type 'T'</li>
<li><code>static void Register&lt;T&gt;(Func&lt;T&gt; func)</code> - register construction function.</li>
<li><code>static void Register&lt;T&gt;(T instance)</code> - register instance.</li>
<li><code>static void Unregister&lt;T&gt;(Func&lt;T&gt; func)</code> - unregister construction function.</li>
<li><code>static void Register&lt;T&gt;(T instance)</code> - unregister instance.</li>
</ul>
<p>Example 1:</p>
<pre><code class="lang-C#">using UnityEngine;
using Battlehub.RTCommon;

public interface IDependency { }

public class Dependency : MonoBehaviour, IDependency
{
    void Awake()
    {
        IOC.Register&lt;IDependency&gt;(this);
    }

    void OnDestroy()
    {
        IOC.Unregister&lt;IDependency&gt;(this);
    }
}

public class User : MonoBehaviour
{
    void Start()
    {
        IDependency dependency = IOC.Resolve&lt;IDependency&gt;();
    }
}
	
</code></pre>
<p>Example 2:</p>
<pre><code class="lang-C#">using UnityEngine;
using Battlehub.RTCommon;

[DefaultExecutionOrder(-1)]
public class Registrar : MonoBehaviour
{
	void Awake()
	{
		IOC.Register&lt;IDependency&gt;(() =&gt;
		{
			GameObject go = new GameObject();
			return go.AddComponent&lt;Dependency&gt;();
		});
	}

    private void OnDestroy()
    {
		IOC.Unregister&lt;IDependency&gt;();
    }
}

public interface IDependency { }
public class Dependency : MonoBehaviour, IDependency
{
}

public class User : MonoBehaviour
{
	void Awake()
	{
		IDependency dependency = IOC.Resolve&lt;IDependency&gt;();
	}
}
	
</code></pre>
<p>##IRTE interface</p>
<p>Core editor functions and APIs are accessible through IRTE interface. This interface defined in /Battlehub/RTEditor/Runtime/RTCommon/<strong>RTEBase.cs</strong></p>
<p>Properties:</p>
<ul>
<li><code>CameraLayerSettings CameraLayerSettings { get; }</code> - layers used by <a href="rendering.html#graphics-layer-camera">RTE</a>.</li>
<li><code>IInput Input { get; }</code> - low level <a href="#input">input</a>.</li>
<li><code>IRuntimeSelection Selection { get; }</code> - <a href="#runtime-selection">selection</a> functionality.</li>
<li><code>IRuntimeUndo Undo { get; }</code> - <a href="#runtime-undo">undo redo</a> functionality.</li>
<li><code>RuntimeTools Tools { get; }</code> - <a href="#runtime-tools">tools</a> functionality.</li>
<li><code>CursorHelper CursorHelper { get; }</code> - cursor helper.</li>
<li><code>IRuntimeObjects Object { get; }</code> - <a href="#runtime-objects">object</a> lifecycle events.</li>
<li><code>IDragDrop DragDrop { get; }</code> - <a href="#drag-and-drop">drag and drop</a> functions.</li>
<li><code>bool IsOpened { get; set; }</code> - is editor opened?</li>
<li><code>bool IsBusy { get; set; }</code> - is editor busy? blocks user input.</li>
<li><code>bool IsPlaymodeStateChanging { get; }</code> - is editor either in play mode, or about to switch to it?</li>
<li><code>bool IsPlaying { get; set; }</code> - is editor currently in play mode?</li>
<li><code>bool IsApplicationPaused { get; }</code> - is application paused?</li>
<li><code>Transform Root { get; }</code> -  editor root transform.</li>
<li><code>RuntimeWindow ActiveWindow { get; }</code> - currently active <a href="#runtime-window">window</a>.</li>
<li><code>RuntimeWindow[] Windows { get; }</code> - all registered windows.</li>
</ul>
<p>Methods:</p>
<ul>
<li><p><code>void ActivateWindow(RuntimeWindow window);</code> - active window and associated <a href="#rte-component">RTE Components</a> will receive user input.</p>
</li>
<li><p><code>void RegisterCreatedObjects(GameObject[] go);</code> - register created game objects to undo stack.</p>
</li>
<li><p><code>void Duplicate(GameObject[] go);</code> - duplicate objects and register created duplicates to undo stack.</p>
</li>
<li><p><code>void Delete(GameObject[] go);</code> - delete game objects and register this operation to undo stack.</p>
</li>
</ul>
<p>Events:</p>
<ul>
<li><code>RTEEvent PlaymodeStateChanging</code> - raised before play mode change.</li>
<li><code>RTEEvent PlaymodeStateChanged</code> - raised when play mode state changed.</li>
<li><code>RTEEvent ActiveWindowChanged</code> - raised when window activated.</li>
<li><code>RTEEvent&lt;RuntimeWindow&gt; WindowRegistered</code> - raised when window registered.</li>
<li><code>RTEEvent&lt;RuntimeWindow&gt; WindowUnregistered</code> - raised when window unregistered.</li>
<li><code>RTEEvent IsOpenedChanged</code> - raised when IsOpened property changed.</li>
</ul>
<p>Here is how to get reference to <strong>IRTE</strong>:</p>
<pre><code class="lang-C#"> using UnityEngine;
 using Battlehub.RTCommon;
 
 public class GetIRTE : MonoBehaviour
 {
	void Awake()
	{
		IRTE editor = IOC.Resolve&lt;IRTE&gt;();
	}
 }
	
</code></pre>
<p>Open example:</p>
<pre><code class="lang-C#"> using UnityEngine;
 using Battlehub.RTCommon;
 
 public class OpenExample : MonoBehaviour
 {
	void Start()
	{
		IRTE rte = IOC.Resolve&lt;IRTE&gt;();
		rte.IsOpened = true;
	}
 }
	
</code></pre>
<p>Play example:</p>
<pre><code class="lang-C#"> using UnityEngine;
 using Battlehub.RTCommon;
 
 public class PlayExample : MonoBehaviour
 {
	void Start()
	{
		IRTE rte = IOC.Resolve&lt;IRTE&gt;();
		rte.IsPlaying = true;
	}
 }
	
</code></pre>
<p>Lock user input example:</p>
<pre><code class="lang-C#"> using UnityEngine;
 using System.Collections;
 using Battlehub.RTCommon;
 
 public class BlockUserInput : MonoBehaviour
 {
	IRTE m_rte;
	
	void Start()
	{
		m_rte = IOC.Resolve&lt;IRTE&gt;();
		StartCoroutine(DummyOperation());
	}
	
	IEnumerator DummyOperation()
    {
		yield return new WaitWhile(() =&gt; m_rte.IsBusy);

		m_rte.IsBusy = true;
		Debug.Log(&quot;User input locked&quot;);

		yield return new WaitForSeconds(5);

		m_rte.IsBusy = false;
		Debug.Log(&quot;User input unlocked&quot;);
	}
 }
	
</code></pre>
<p>##Input</p>
<p><a href="runtime-editor.html">Runtime editor</a>, <a href="transform-handles.html">transform handles</a> and <a href="gizmos.html">gizmos</a> are using IInput interface to access user input.
Here is how to get reference to IInput:</p>
<pre><code class="lang-C#"> using UnityEngine;
 using Battlehub.RTCommon;
 
 public class GetIRTE : MonoBehaviour
 {
	void Awake()
	{
		IInput input = IOC.Resolve&lt;IRTE&gt;().Input;
	}
 }
	
</code></pre>
<p>IInput has following methods:</p>
<ul>
<li><code>bool IsAnyKeyDown()</code></li>
<li><code>float GetAxis(InputAxis axisType)</code></li>
<li><code>bool GetKeyDown(KeyCode key)</code></li>
<li><code>bool GetKeyUp(KeyCode key)</code></li>
<li><code>bool GetKey(KeyCode key)</code></li>
<li><code>Vector3 GetPointerXY(int pointer)</code></li>
<li><code>bool GetPointerDown(int button)</code></li>
<li><code>bool GetPointerUp(int button)</code></li>
<li><code>bool GetPointer(int button)</code></li>
</ul>
<p>##RTE Component</p>
<p>/Battlehub/RTEditor/Runtime/RTCommon/<strong>RTEComponent</strong> is the base class for all <a href="transform-handles.html">transform handles</a> and <a href="gizmos.html">gizmos</a>.
It hold reference to <a href="#runtime-window">runtime window</a> and check if this window is in active state.</p>
<p>##Runtime Selection
<strong>IRuntimeSelection</strong> interface defined in Assets/Battlehub/RTCommon/Scripts/<strong>RuntimeSelection.cs</strong>. Here is how subscribe to <code>SelectionChanged</code> event and select object:</p>
<pre><code class="lang-C#">using UnityEngine;
using Battlehub.RTCommon;

public class SelectObjectBehaviour : MonoBehaviour
{
	IRuntimeSelection m_selection;

	void Start()
	{
		m_selection = IOC.Resolve&lt;IRTE&gt;().Selection;
		m_selection.SelectionChanged += OnSelectionChanged;

		GameObject go = GameObject.CreatePrimitive(PrimitiveType.Capsule);
		go.AddComponent&lt;ExposeToEditor&gt;();

		m_selection.activeObject = go;
	}

	void OnDestroy()
	{
		if (m_selection != null)
		{
			m_selection.SelectionChanged -= OnSelectionChanged;
		}
	}

	void OnSelectionChanged(Object[] unselectedObjects)
	{
		if (unselectedObjects != null)
		{
			for (int i = 0; i &lt; unselectedObjects.Length; ++i)
			{
				Object unselected = unselectedObjects[i];
				Debug.Log(unselected);
			}
		}

		if (m_selection.objects != null)
		{
			for (int i = 0; i &lt; m_selection.objects.Length; ++i)
			{
				Object selected = m_selection.objects[i];
				Debug.Log(selected);
			}
		}
	}
}
	
</code></pre>
<p>##Runtime Objects
<strong>IRuntimeObjects</strong> interface defined in /Battlehub/RTEditor/Runtime/RTCommon/<strong>RuntimeObjects.cs</strong>. It can be used to track lifecycle events of objects exposed to editor.</p>
<p>Methods:</p>
<ul>
<li><code>IEnumerable&lt;ExposeToEditor&gt; Get(bool rootsOnly, bool useCache = true)</code> - call this method to get exposed to editor objects. If <code>rootsOnly</code> parameter set to <em>false</em> it return all objects, otherwise it return objects without parent.
If <code>useCache</code> parameter set to <em>false</em>, then full traversal of object tree will be used.</li>
</ul>
<p>Events:</p>
<ul>
<li><code>event ObjectEvent Awaked</code> - see corresponding <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">MonoBehaviour event</a>.</li>
<li><code>event ObjectEvent Started</code> - see corresponding <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">MonoBehaviour event</a>.</li>
<li><code>event ObjectEvent Enabled</code> - see corresponding<a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">MonoBehaviour event</a>.</li>
<li><code>event ObjectEvent Disabled</code> - see corresponding <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">MonoBehaviour event</a>.</li>
<li><code>event ObjectEvent Destroyed</code> - see corresponding <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">MonoBehaviour event</a>.</li>
<li><code>event ObjectEvent Destroying</code> - raised just before <code>Destroyed</code> event.</li>
<li><code>event ObjectEvent MarkAsDestroyedChanged</code> - raised when object marked as destroyed by <a href="#runtime-undo">undo&amp;redo</a></li>
<li><code>event ObjectEvent MarkAsDestroyedChanging</code> - raised just before <code>MarkAsDestroyedChanged</code> event.</li>
<li><code>event ObjectEvent TransformChanged</code> - position, rotation or localScale changed.</li>
<li><code>event ObjectParentChangedEvent ParentChanged</code> - transform.parent changed.</li>
<li><code>event ObjectEvent NameChanged</code> - object name changed.</li>
<li><code>event ObjectEvent&lt;Component&gt; ComponentAdded</code> - raised when new component added.</li>
</ul>
<p>Example:</p>
<pre><code class="lang-C#">using UnityEngine;
using Battlehub.RTCommon;

public class ListenAwakeEvent : MonoBehaviour
{
	IRuntimeObjects m_object;

	void Start()
	{
		m_object = IOC.Resolve&lt;IRTE&gt;().Object;
		m_object.Awaked += OnObjectAwaked;

		GameObject go = new GameObject();
		go.AddComponent&lt;ExposeToEditor&gt;();
	}

	void OnDestroy()
	{
		if(m_object != null)
		{
			m_object.Awaked -= OnObjectAwaked;
		}
	}

	void OnObjectAwaked(ExposeToEditor obj)
	{
		Debug.Log(obj);
	}
}

</code></pre>
<p>##Runtime Tools</p>
<p><strong>RuntimeTools</strong> class can be found in /Battlehub/RTEditor/Runtime/RTCommon/<strong>RuntimeObjects.cs</strong>.</p>
<p>Properties:</p>
<ul>
<li><code>LockObject LockAxes</code> - this object hold aggregated <a href="transform-handles.html#locking-axes">locking state</a> of selected objects.</li>
<li><code>UnityObject ActiveTool</code> - reference to active transform handle or gizmo. Active means that user is currently interacting with it.</li>
<li><code>RuntimeTool Current</code> - The tool that is currently selected for the Scene View:
<ul>
<li><em>None</em></li>
<li><em>Move</em></li>
<li><em>Rotate</em></li>
<li><em>Scale</em></li>
<li><em>View</em></li>
<li><em>Rect</em></li>
<li><em>Custom</em>	
 </li>
</ul>
</li>
<li><code>RuntimePivotMode PivotMode</code> - Are we in <em>Center</em> or <em>Pivot</em> mode.</li>
<li><code>RuntimePivotRotation PivotRotation</code> - What's the rotation of the tool handle:
<ul>
<li><em>Global</em></li>
<li><em>Local</em>
 </li>
</ul>
</li>
</ul>
<p>If property change, corresponding event is raised:</p>
<ul>
<li><code>event RuntimeToolsEvent ToolChanged</code></li>
<li><code>event RuntimeToolsEvent PivotRotationChanged</code></li>
<li><code>event RuntimeToolsEvent PivotModeChanged</code></li>
<li><code>event RuntimeToolsEvent LockAxesChanged</code></li>
</ul>
<p>Here is how to change current tool:</p>
<pre><code class="lang-C#">using UnityEngine;
using Battlehub.RTCommon;
 
public class SwitchToolBehaviour : MonoBehaviour
{
	void Start()
	{
        IRTE editor = IOC.Resolve&lt;IRTE&gt;();
        editor.Tools.Current = RuntimeTool.Rotate;
    }
}
	
</code></pre>
<p>Here is how to <a href="transform-handles.html#locking-axes">lock axes</a> for all selected objects:</p>
<pre><code class="lang-C#">using UnityEngine;
using Battlehub.RTCommon;
 
public class LockAxesForAllObjects : MonoBehaviour
{
	IRTE m_editor;
	void Start()
    {
		m_editor = IOC.Resolve&lt;IRTE&gt;();
		m_editor.Selection.SelectionChanged += OnSelectionChanged;
		m_editor.Tools.ToolChanged += OnToolChanged;
	}

	void OnDestroy()
	{
		if(m_editor != null)
		{
			m_editor.Selection.SelectionChanged -= OnSelectionChanged;
			m_editor.Tools.ToolChanged -= OnToolChanged;
		}
	}

	void OnToolChanged()
	{
		Lock();
	}

	void OnSelectionChanged(Object[] unselectedObjects)
	{
		Lock();
	}

	static void Lock()
	{
		IRTE editor = IOC.Resolve&lt;IRTE&gt;();
		editor.Tools.LockAxes = new LockObject
		{
			PositionY = true,
			RotationX = true,
			RotationZ = true
		};
	}
}
	
</code></pre>
<p>##Runtime Undo</p>
<p><strong>IRuntimeUndo</strong> interface defined in /Battlehub/RTEditor/Runtime/RTCommon/<strong>RuntimeUndo.cs</strong>. It is used to record changes, maintain undo/redo stack and perform
undo and redo operations.</p>
<p>Properties:</p>
<ul>
<li><code>bool Enabled { get; set; }</code> - is undo &amp; redo enabled?</li>
<li><code>bool CanUndo { get; }</code> - can undo?</li>
<li><code>bool CanRedo { get; }</code> - can redo?</li>
<li><code>bool IsRecording { get; }</code> - are we recording multiple changes?</li>
</ul>
<p>Methods:</p>
<ul>
<li><p><code>void BeginRecord()</code> - begin record multiple changes.</p>
</li>
<li><p><code>void EndRecord()</code> - end record multiple changes.</p>
</li>
<li><p><code>Record CreateRecord(UndoRedoCallback redoCallback, UndoRedoCallback undoCallback, PurgeCallback purgeCallback = null, EraseReferenceCallback eraseCallback = null)</code>
- generic create record method.</p>
</li>
<li><p><code>void RegisterCreatedObjects(ExposeToEditor[] createdObjects)</code> - register created objects.</p>
</li>
<li><p><code>void DestroyObjects(ExposeToEditor[] destoryedObjects)</code> - register destroy objects operation.</p>
</li>
<li><p><code>void BeginRecordValue(object target, MemberInfo memberInfo)</code> - begin record value.</p>
</li>
<li><p><code>void EndRecordValue(object target, MemberInfo memberInfo)</code> - end record value.</p>
</li>
<li><p><code>void BeginRecordTransform(Transform target)</code> - begin record transform.</p>
</li>
<li><p><code>void EndRecordTransform(Transform target)</code> - end record transform.</p>
</li>
<li><p><code>void AddComponent(ExposeToEditor obj, Type type)</code><br>
- add component and push corresponding record to the stack.</p>
</li>
<li><p><code>void DestroyComponent(Component destroy, MemberInfo[] memberInfo)</code><br>
- destroy component and push corresponding record to the stack.</p>
</li>
<li><p><code>void Redo()</code> - redo.</p>
</li>
<li><p><code>void Undo()</code> - undo.</p>
</li>
<li><p><code>void Purge()</code> - purge all records. All “marked as destroyed” objects will be destroyed.</p>
</li>
<li><p><code>void Erase(object oldRef, object newRef)</code> - replace oldRef with newRef for all records in stack.</p>
</li>
<li><p><code>void Store()</code> - create new stack and store current undo&amp;redo stack.</p>
</li>
<li><p><code>void Restore()</code> - restore previously stored stack.</p>
</li>
</ul>
<p>Events:</p>
<ul>
<li><code>event RuntimeUndoEventHandler BeforeUndo</code> - raised before undo operation.</li>
<li><code>event RuntimeUndoEventHandler UndoCompleted</code> - raised after undo operation.</li>
<li><code>event RuntimeUndoEventHandler BeforeRedo</code> - raised before redo operation.</li>
<li><code>event RuntimeUndoEventHandler RedoCompleted</code> - raised after redo operation.</li>
<li><code>event RuntimeUndoEventHandler StateChanged</code> - raised whenever one of the following operations performed:
<ul>
<li><em>Store</em></li>
<li><em>Restore</em></li>
<li><em>Purge</em></li>
</ul>
</li>
</ul>
<p>Here is how to record value and then undo changes:</p>
<pre><code class="lang-C#">using UnityEngine;
using System.Reflection;
using Battlehub.RTCommon;
using Battlehub.Utils;

public class RecordValueThenUndoChanges : MonoBehaviour
{
	IRuntimeUndo m_undo;

	[SerializeField]
	int m_value = 1;

	void Start()
	{
		m_undo = IOC.Resolve&lt;IRTE&gt;().Undo;
		m_undo.UndoCompleted += OnUndoCompleted;

		MemberInfo valueInfo = Strong.MemberInfo((RecordValueThenUndoChanges x) =&gt; x.m_value);

		m_undo.BeginRecordValue(this, valueInfo);
		m_value = 2;
		m_undo.EndRecordValue(this, valueInfo);

		m_undo.Undo();
	}

	void OnDestroy()
	{
		if (m_undo != null)
		{
			m_undo.UndoCompleted -= OnUndoCompleted;
		}
	}

	void OnUndoCompleted()
	{
		Debug.Log(m_value); //1
	}
}
</code></pre>
<p>##Drag And Drop
<strong>IDragDrop</strong> interface defined in /Battlehub/RTEditor/Runtime/RTCommon/<strong>DragDrop.cs</strong>. It is used as a common interface for all drag &amp; drop operations.</p>
<p>Properties:</p>
<ul>
<li><code>object[] DragObjects { get; }</code> - objects being dragged.</li>
<li><code>object Source { get; }</code> - drag &amp; drop operation source object.</li>
<li><code>bool InProgress { get; }</code> - is drag and drop in progress?</li>
</ul>
<p>Methods:</p>
<ul>
<li><code>void Reset()</code> - cancel current drag &amp; drop operation.</li>
<li><code>void SetCursor(KnownCursor cursorType)</code> - set cursor.
<ul>
<li><em>KnownCursor.DropNotAllowed</em></li>
<li><em>KnownCursor.DropAllowed</em></li>
</ul>
</li>
<li><code>void RaiseBeginDrag(object source, object[] dragItems, PointerEventData pointerEventData)</code><br>
- begin drag &amp; drop.</li>
<li><code>void RaiseDrag(PointerEventData eventData)</code> - drag.</li>
<li><code>void RaiseDrop(PointerEventData pointerEventData)</code> - end drag &amp; drop.</li>
</ul>
<p>Events:</p>
<ul>
<li><code>event DragDropEventHander BeginDrag</code> - raised by <code>RaiseBeginDrag</code> method.</li>
<li><code>event DragDropEventHander Drag</code> - raised by <code>RaiseDrag</code> method.</li>
<li><code>event DragDropEventHander Drop</code> - raised by <code>RaiseDrop</code> method.</li>
</ul>
<p>In this example we will handle Drag Drop operation into console window:</p>
<pre><code class="lang-C#">using Battlehub.RTCommon;
using UnityEngine;
using UnityEngine.EventSystems;

public class ConsoleDragDropHandler : MonoBehaviour
{
    IDragDrop m_dragDrop;
    RuntimeWindow m_target;
        
    void Start()
    {
        m_target = IOC.Resolve&lt;IRTE&gt;().GetWindow(RuntimeWindowType.Console);            
        m_dragDrop = IOC.Resolve&lt;IRTE&gt;().DragDrop;
        m_dragDrop.Drop += OnDrop;
    }

    void OnDestroy()
    {
		if(m_dragDrop != null)
		{
			m_dragDrop.Drop -= OnDrop;
		}
    }

    void OnDrop(PointerEventData pointerEventData)
	{
        if(m_target != null &amp;&amp; m_target.IsPointerOver)
        {
            Debug.Log(m_dragDrop.DragObjects[0]);
        }
    }
}
	
</code></pre>
<p>##Runtime Window</p>
<p><strong>RuntimeWindow</strong> class can be found in /Battlehub/RTEditor/Runtime/RTCommon/<strong>RuntimeWindow.cs</strong>.  If you want to extend <a href="runtime-editor.html">Runtime Editor</a> with new windows, then they must be inherited from<br>
Runtime Window class. Here is how to do it:</p>
<pre><code class="lang-C#">
using Battlehub.RTCommon;
using Battlehub.Utils;
using UnityEngine;
using UnityEngine.EventSystems;

public class CustomWindow : RuntimeWindow
{
    protected override void AwakeOverride()
    {
        WindowType = RuntimeWindowType.Custom;
        base.AwakeOverride();
    }

    protected override void OnDestroyOverride()
    {
        base.OnDestroyOverride();
    }

    protected override void OnActivated()
    {
        base.OnActivated();
        Debug.Log(&quot;On Custom Window Activated&quot;);
    }

    protected override void OnDeactivated()
    {
        base.OnDeactivated();
        Debug.Log(&quot;On Custom Window Deactivated&quot;);
    }

    public override void DragEnter(object[] dragObjects, PointerEventData eventData)
    {
        base.DragEnter(dragObjects, eventData);
        Editor.DragDrop.SetCursor(KnownCursor.DropAllowed);
		Debug.Log(&quot;On Drag Enter&quot;);
    }

    public override void DragLeave(PointerEventData eventData)
    {
        base.DragLeave(eventData);
        Editor.DragDrop.SetCursor(KnownCursor.DropNotAllowed);
		Debug.Log(&quot;On Drag Leave&quot;);
    }

    public override void Drop(object[] dragObjects, PointerEventData eventData)
    {
        base.Drop(dragObjects, eventData);
		Debug.Log(&quot;On Drop&quot;);
		
        for(int i = 0; i &lt; dragObjects.Length; ++i)
        {
            Debug.Log(dragObjects[i]);
        }
		
    }
}

</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>For information on how to register custom window please proceed to -&gt; <a href="runtime-editor.html#how-to-add-custom-window-to-window-manager">this</a> &lt;- section</p>
</div>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Battlehub0x/RTE_Docs/blob/main/docs/manual/infrastructure.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      Example Unity documentation
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
